<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdownæ¸²æŸ“ä¿®å¤éªŒè¯</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .before, .after {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .after {
            background: #e8f5e8;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover { background: #005a87; }
        .success { color: #28a745; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        pre { background: #f1f1f1; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>ğŸ”§ Markdownæ¸²æŸ“ä¿®å¤éªŒè¯</h1>
    <p>éªŒè¯æ–°çš„ç»¼åˆé¢„å¤„ç†åŠŸèƒ½æ˜¯å¦ä¿®å¤äº†è¡¨æ ¼ã€æ ‡é¢˜ã€æ¢è¡Œç­‰æ¸²æŸ“é—®é¢˜ã€‚</p>

    <div class="test-section">
        <h3>ğŸ“‹ æµ‹è¯•å†…å®¹ï¼ˆæ¨¡æ‹Ÿè…¾è®¯æ–‡æ¡£æå–çš„é—®é¢˜æ ¼å¼ï¼‰</h3>
        <pre id="testContent"></pre>
        <button onclick="runTest()">æµ‹è¯•ä¿®å¤æ•ˆæœ</button>
    </div>

    <div class="test-section">
        <h3>ğŸ“Š ä¿®å¤å‰åå¯¹æ¯”</h3>
        <h4>ä¿®å¤å‰æ¸²æŸ“ç»“æœ:</h4>
        <div id="beforeResult" class="before"></div>
        
        <h4>ä¿®å¤åæ¸²æŸ“ç»“æœ:</h4>
        <div id="afterResult" class="after"></div>
    </div>

    <div class="test-section">
        <h3>âœ… éªŒè¯ç»“æœ</h3>
        <div id="validationResults"></div>
    </div>

    <script src="lib/markdown-it.min.js"></script>
    <script>
        // é…ç½®markdown-itï¼ˆä¿®å¤å‰çš„é…ç½®ï¼‰
        const mdOld = markdownit({
            html: false,
            breaks: false,  // ä¿®å¤å‰çš„è®¾ç½®
            linkify: true,
            typographer: true
        });

        // é…ç½®markdown-itï¼ˆä¿®å¤åçš„é…ç½®ï¼‰
        const mdNew = markdownit({
            html: false,
            breaks: true,   // ä¿®å¤åçš„è®¾ç½®
            linkify: true,
            typographer: true
        });

        // é—®é¢˜å†…å®¹ï¼ˆæ¨¡æ‹Ÿè…¾è®¯æ–‡æ¡£æå–çš„å„ç§æ ¼å¼é—®é¢˜ï¼‰
        const problematicContent = `æ€è€ƒè¿‡ç¨‹ï¼š

å—¯ï¼Œç”¨æˆ·è¯¢é—®ç½‘å®‰é™©ä¸å¤©åˆ›æœºå™¨äººäº§å“æ†ç»‘é”€å”®åœ¨åŒ–å·¥åŠç”µåŠ›è¡Œä¸šçš„è®¾è®¡æ–¹æ¡ˆã€‚


### âš™ï¸ **ä¸€ã€è¡Œä¸šé£é™©ç‰¹æ€§ä¸ä¿é™©éœ€æ±‚**

| **è¡Œä¸š** | **æ ¸å¿ƒé£é™©åœºæ™¯** | **ç½‘å®‰é™©ä¿éšœé‡ç‚¹** | **æ”¿ç­–ä¾æ®** |

|----------|------------------|-------------------|-------------|

| **åŒ–å·¥è¡Œä¸š** | å·¥æ§ç³»ç»Ÿé­å‹’ç´¢æ”»å‡» | è¦†ç›–åœäº§æŸå¤± | ã€Šå·¥ä¸šæ§åˆ¶ç³»ç»ŸæŒ‡å—ã€‹ |

| **ç”µåŠ›è¡Œä¸š** | ç”µç½‘ç›‘æ§ç³»ç»Ÿè¢«å…¥ä¾µ | èµ”å¿ç”µç½‘ç˜«ç—ªç½šæ¬¾ | ã€Šç”µåŠ›å¯é æ€§ç®¡ç†åŠæ³•ã€‹ |



### ğŸ›¡ï¸ **äºŒã€ç½‘å®‰é™©æ†ç»‘æ–¹æ¡ˆè®¾è®¡**
- åŸºç¡€ä¿éšœå¥—é¤
- è¡Œä¸šä¸“å±é™„åŠ é™©


- æŠ€æœ¯å‡è´¹æœºåˆ¶
è¿™æ˜¯ä¿é™©+ç§‘æŠ€+æœåŠ¡çš„æ¨¡å¼ã€‚`;

        // ç»¼åˆå†…å®¹é¢„å¤„ç†å‡½æ•°ï¼ˆå¤åˆ¶è‡ªsidepanel.jsï¼‰
        function preprocessTencentDocsContent(content) {
            let processedContent = cleanTableStructure(content);
            processedContent = fixHeaderFormatting(processedContent);
            processedContent = fixListFormatting(processedContent);
            processedContent = cleanExcessiveEmptyLines(processedContent);
            return processedContent;
        }

        function cleanTableStructure(content) {
            const lines = content.split('\n');
            const cleanedLines = [];
            let inTable = false;
            let previousLineWasTable = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const isTableLine = /^\s*\|.*\|\s*$/.test(line) && line.trim() !== '|';
                const isEmptyLine = line.trim() === '';
                
                if (isTableLine) {
                    if (!inTable) inTable = true;
                    cleanedLines.push(line);
                    previousLineWasTable = true;
                } else if (inTable && isEmptyLine && previousLineWasTable) {
                    let nextTableLineIndex = -1;
                    for (let j = i + 1; j < lines.length; j++) {
                        const nextLine = lines[j];
                        if (/^\s*\|.*\|\s*$/.test(nextLine) && nextLine.trim() !== '|') {
                            nextTableLineIndex = j;
                            break;
                        } else if (nextLine.trim() !== '') {
                            break;
                        }
                    }
                    
                    if (nextTableLineIndex > 0) {
                        continue; // è·³è¿‡ç©ºè¡Œ
                    } else {
                        inTable = false;
                        cleanedLines.push(line);
                        previousLineWasTable = false;
                    }
                } else {
                    if (inTable && !isTableLine) inTable = false;
                    cleanedLines.push(line);
                    previousLineWasTable = false;
                }
            }
            
            return cleanedLines.join('\n');
        }

        function fixHeaderFormatting(content) {
            const lines = content.split('\n');
            const fixedLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const isHeader = /^#{1,6}\s/.test(line);
                
                if (isHeader) {
                    if (i > 0 && fixedLines.length > 0 && fixedLines[fixedLines.length - 1].trim() !== '') {
                        fixedLines.push('');
                    }
                    fixedLines.push(line);
                    if (i < lines.length - 1 && lines[i + 1].trim() !== '') {
                        fixedLines.push('');
                    }
                } else {
                    fixedLines.push(line);
                }
            }
            
            return fixedLines.join('\n');
        }

        function fixListFormatting(content) {
            const lines = content.split('\n');
            const fixedLines = [];
            let inList = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const isListItem = /^\s*[-*+]\s/.test(line) || /^\s*\d+\.\s/.test(line);
                
                if (isListItem) {
                    if (!inList && fixedLines.length > 0 && fixedLines[fixedLines.length - 1].trim() !== '') {
                        fixedLines.push('');
                    }
                    inList = true;
                    fixedLines.push(line);
                } else {
                    if (inList && line.trim() !== '') {
                        fixedLines.push('');
                        inList = false;
                    }
                    fixedLines.push(line);
                }
            }
            
            return fixedLines.join('\n');
        }

        function cleanExcessiveEmptyLines(content) {
            return content.replace(/\n\s*\n\s*\n+/g, '\n\n');
        }

        function runTest() {
            console.log('å¼€å§‹æµ‹è¯•...');
            
            // æ˜¾ç¤ºæµ‹è¯•å†…å®¹
            document.getElementById('testContent').textContent = problematicContent;
            
            // ä¿®å¤å‰çš„æ¸²æŸ“
            const beforeHtml = mdOld.render(problematicContent);
            document.getElementById('beforeResult').innerHTML = beforeHtml;
            
            // ä¿®å¤åçš„æ¸²æŸ“
            const processedContent = preprocessTencentDocsContent(problematicContent);
            const afterHtml = mdNew.render(processedContent);
            document.getElementById('afterResult').innerHTML = afterHtml;
            
            // éªŒè¯ç»“æœ
            const beforeHasTable = /<table/.test(beforeHtml);
            const afterHasTable = /<table/.test(afterHtml);
            const beforeHasHeaders = /<h[1-6]/.test(beforeHtml);
            const afterHasHeaders = /<h[1-6]/.test(afterHtml);
            const beforeHasList = /<[uo]l/.test(beforeHtml);
            const afterHasList = /<[uo]l/.test(afterHtml);
            
            const results = `
                <div>
                    <h4>ğŸ” æ£€æµ‹ç»“æœ:</h4>
                    <p><strong>è¡¨æ ¼æ¸²æŸ“:</strong> 
                        ä¿®å¤å‰: ${beforeHasTable ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'} | 
                        ä¿®å¤å: ${afterHasTable ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'}
                    </p>
                    <p><strong>æ ‡é¢˜æ¸²æŸ“:</strong> 
                        ä¿®å¤å‰: ${beforeHasHeaders ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'} | 
                        ä¿®å¤å: ${afterHasHeaders ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'}
                    </p>
                    <p><strong>åˆ—è¡¨æ¸²æŸ“:</strong> 
                        ä¿®å¤å‰: ${beforeHasList ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'} | 
                        ä¿®å¤å: ${afterHasList ? '<span class="success">âœ…</span>' : '<span class="error">âŒ</span>'}
                    </p>
                    
                    <h4>ğŸ“Š æ€»ä½“è¯„ä¼°:</h4>
                    <p>${afterHasTable && afterHasHeaders && afterHasList ? 
                        '<span class="success">ğŸ‰ æ‰€æœ‰é—®é¢˜å·²ä¿®å¤ï¼Markdownæ¸²æŸ“æ­£å¸¸å·¥ä½œ</span>' : 
                        '<span class="error">âš ï¸ ä»æœ‰éƒ¨åˆ†é—®é¢˜éœ€è¦è¿›ä¸€æ­¥è°ƒè¯•</span>'}</p>
                </div>
            `;
            
            document.getElementById('validationResults').innerHTML = results;
            
            console.log('æµ‹è¯•å®Œæˆ');
            console.log('ä¿®å¤å‰HTMLé•¿åº¦:', beforeHtml.length);
            console.log('ä¿®å¤åHTMLé•¿åº¦:', afterHtml.length);
            console.log('é¢„å¤„ç†åå†…å®¹é•¿åº¦:', processedContent.length);
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºæµ‹è¯•å†…å®¹
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('testContent').textContent = problematicContent;
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»æµ‹è¯•æŒ‰é’®å¼€å§‹éªŒè¯ä¿®å¤æ•ˆæœ...');
        });
    </script>
</body>
</html>